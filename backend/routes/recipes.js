import express from "express";
import { readFileSync } from "fs";
import { fileURLToPath } from "url";
import { dirname, join } from "path";
import Recipe from "../models/Recipe.js";
import { generateRecipes } from "../utils/llmClient.js";
import { extractIngredients, rewriteRecipeSteps } from "../utils/llmClient.js";
import User from "../models/User.js";

const router = express.Router();

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// POST /recipes/generate
router.post("/generate", async (req, res) => {
  try {
    const { userId } = req.body;

    if (!userId) {
      return res.status(400).json({ error: "userId is required" });
    }

    // Get user's groceries to use as ingredients
    const Grocery = (await import("../models/grocery.js")).default;
    const groceries = await Grocery.find({ userID: userId });
    const ingredients = groceries.map(g => g.name);

    // Get user preferences for context
    const user = await User.findById(userId);
    const userPrefs = {
      dietLevel: user?.dietLevel || "FLEXITARIAN",
      cuisinePreferences: user?.preferredCuisines || [],
      cookingStylePreferences: user?.cookingStylePreferences || []
    };
    
    console.log("ðŸ” Calling LLM (generateRecipes) for recipe generation...");
    console.log("   User ID:", userId);
    console.log("   Ingredients count:", ingredients.length);
    console.log("   User preferences:", userPrefs);
    
    const recipes = await generateRecipes(ingredients, 1);
    console.log("âœ… LLM generated", recipes?.length || 0, "recipes");
    
    if (!recipes || recipes.length === 0) {
      console.error("âŒ No recipes generated by LLM");
      return res.status(500).json({ error: "Failed to generate recipe" });
    }
    
    console.log("   Recipe text length:", recipes[0]?.length || 0, "characters");

    // Use first recipe
    const recipeText = recipes[0];

    // Save recipe
    const savedRecipe = await Recipe.create({
      userID: userId,
      recipe: [recipeText]
    });

    // Convert recipe text to steps array (split by newlines or numbered steps)
    const steps = recipeText
      .split(/\n+/)
      .map(s => s.trim())
      .filter(s => s.length > 0)
      .filter(s => !s.match(/^(recipe|ingredients|instructions|method|steps?):?$/i));
    
    // If no steps found, use the whole text as one step
    const finalSteps = steps.length > 0 ? steps : [recipeText];

    // Return in iOS Recipe format
    const recipe = {
      id: savedRecipe._id.toString(),
      title: "Generated Recipe",
      userId: userId,
      tags: [],
      duration: "30 min",
      ingredients: [],
      steps: finalSteps,
      previewImageUrl: "",
      type: "simplified",
      substitutionMap: null
    };

    res.json(recipe);
  } catch (err) {
    console.error("Generate recipe error:", err);
    res.status(500).json({ error: "Failed to generate recipe" });
  }
});

// POST /recipes/veganize
router.post("/veganize", async (req, res) => {
  try {
    const { userId, inputText } = req.body;

    if (!userId || !inputText) {
      return res.status(400).json({ error: "userId and inputText are required" });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Extract ingredients
    console.log("ðŸ” Calling LLM (extractIngredients) for recipe veganization...");
    console.log("   User ID:", userId);
    console.log("   Recipe text length:", inputText.length, "characters");
    const ingredients = await extractIngredients(inputText);
    console.log("âœ… LLM extracted", ingredients.length, "ingredients");
    console.log("   Ingredients:", ingredients.slice(0, 5).join(", "), ingredients.length > 5 ? "..." : "");

    // Get substitutions
    const substitutions = JSON.parse(readFileSync(join(__dirname, "../config/substitutions.json"), "utf-8"));

    const dietLevel = user.dietLevel?.toLowerCase() || "vegan";
    const adaptedIngredients = [];

    for (const ing of ingredients) {
      const key = ing.toUpperCase();
      const subs = substitutions[key]?.[dietLevel] || [];
      
      if (subs.length > 0) {
        adaptedIngredients.push({
          original: ing,
          substitute: subs[0] // Use first substitution
        });
      }
    }

    // Rewrite recipe
    console.log("ðŸ” Calling LLM (rewriteRecipeSteps) to veganize recipe...");
    console.log("   Substitutions count:", adaptedIngredients.length);
    const newRecipe = await rewriteRecipeSteps(adaptedIngredients, inputText);
    console.log("âœ… LLM rewrote recipe successfully");
    console.log("   Veganized recipe length:", newRecipe.length, "characters");

    // Save recipe
    const savedRecipe = await Recipe.create({
      userID: userId,
      recipe: [newRecipe]
    });

    // Convert recipe text to steps array (split by newlines or numbered steps)
    const steps = newRecipe
      .split(/\n+/)
      .map(s => s.trim())
      .filter(s => s.length > 0)
      .filter(s => !s.match(/^(recipe|ingredients|instructions|method|steps?):?$/i));
    
    // If no steps found, use the whole text as one step
    const finalSteps = steps.length > 0 ? steps : [newRecipe];

    // Map ingredients to RecipeIngredient format
    const recipeIngredients = adaptedIngredients.map(item => ({
      name: item.substitute,
      amount: null,
      unit: null
    }));

    // Return in iOS Recipe format
    const recipe = {
      id: savedRecipe._id.toString(),
      title: "Veganized Recipe",
      userId: userId,
      tags: [],
      duration: "30 min",
      ingredients: recipeIngredients,
      steps: finalSteps,
      previewImageUrl: "",
      type: "veganized",
      substitutionMap: Object.fromEntries(adaptedIngredients.map(item => [item.original, item.substitute]))
    };

    res.json(recipe);
  } catch (err) {
    console.error("Veganize recipe error:", err);
    res.status(500).json({ error: "Failed to veganize recipe" });
  }
});

// GET /recipes/saved?userId=...
router.get("/saved", async (req, res) => {
  try {
    const userId = req.query.userId;

    if (!userId) {
      return res.status(400).json({ error: "userId is required" });
    }

    const recipes = await Recipe.find({ userID: userId });

    // Map to iOS Recipe format
    const savedRecipes = recipes.map(r => ({
      id: r._id.toString(),
      title: "Saved Recipe",
      ingredients: [],
      instructions: r.recipe.join("\n"),
      prepTime: 0,
      cookTime: 0,
      servings: 0
    }));

    res.json(savedRecipes);
  } catch (err) {
    console.error("Get saved recipes error:", err);
    res.status(500).json({ error: "Failed to get saved recipes" });
  }
});

// POST /recipes/save
router.post("/save", async (req, res) => {
  try {
    const { userId, recipe } = req.body;

    if (!userId || !recipe) {
      return res.status(400).json({ error: "userId and recipe are required" });
    }

    // Save recipe
    const savedRecipe = await Recipe.create({
      userID: userId,
      recipe: [recipe.instructions || recipe.text || ""]
    });

    // Return in iOS Recipe format
    const saved = {
      id: savedRecipe._id.toString(),
      title: recipe.title || "Saved Recipe",
      ingredients: recipe.ingredients || [],
      instructions: recipe.instructions || recipe.text || "",
      prepTime: recipe.prepTime || 0,
      cookTime: recipe.cookTime || 0,
      servings: recipe.servings || 0
    };

    res.json(saved);
  } catch (err) {
    console.error("Save recipe error:", err);
    res.status(500).json({ error: "Failed to save recipe" });
  }
});

export default router;

