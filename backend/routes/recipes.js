import express from "express";
import { readFileSync } from "fs";
import { fileURLToPath } from "url";
import { dirname, join } from "path";
import mongoose from "mongoose";
import Recipe from "../models/Recipe.js";
import { generateRecipes } from "../utils/llmClient.js";
import { extractIngredients, rewriteRecipeSteps } from "../utils/llmClient.js";
import User from "../models/User.js";

const router = express.Router();

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// POST /recipes/generate
router.post("/generate", async (req, res) => {
  try {
    const { userId } = req.body;

    if (!userId) {
      return res.status(400).json({ error: "userId is required" });
    }

    // Get user's groceries to use as ingredients
    const Grocery = (await import("../models/grocery.js")).default;
    const groceries = await Grocery.find({ userID: userId });
    const ingredients = groceries.map(g => g.name);

    // Get user preferences for context
    const user = await User.findById(userId);
    const userPrefs = {
      dietLevel: user?.dietLevel || "flexitarian",
      cuisinePreferences: user?.preferredCuisines || [],
      cookingStylePreferences: user?.cookingStylePreferences || []
    };
    
    console.log("ðŸ” Calling LLM (generateRecipes) for recipe generation...");
    console.log("   User ID:", userId);
    console.log("   Ingredients count:", ingredients.length);
    console.log("   User preferences:", userPrefs);
    
    const generatedRecipes = await generateRecipes(ingredients, 1);
    console.log("âœ… LLM generated", generatedRecipes?.length || 0, "recipes");
    
    if (!generatedRecipes || generatedRecipes.length === 0) {
      console.error("âŒ No recipes generated by LLM");
      return res.status(500).json({ error: "Failed to generate recipe" });
    }
    
    // Use first recipe from LLM
    const llmRecipe = generatedRecipes[0];
    
    // Convert LLM recipe to full Recipe format matching Swift model
    const recipe = {
      id: new mongoose.Types.ObjectId().toString(),
      userId: userId,
      title: llmRecipe.title || "Generated Recipe",
      tags: llmRecipe.tags || [],
      duration: llmRecipe.duration || "30 min",
      ingredients: (llmRecipe.ingredients || []).map(i => ({
        name: i.name || "",
        amount: i.amount || null,
        unit: i.unit || null
      })),
      steps: llmRecipe.steps || [],
      previewImageUrl: "",
      originalPrompt: null,
      type: "simplified",
      substitutionMap: null
    };

    // Save recipe to database
    const savedRecipe = await Recipe.create({
      userID: userId,
      recipe: recipe.steps, // Store steps array
      title: recipe.title,
      tags: recipe.tags,
      duration: recipe.duration,
      ingredients: recipe.ingredients,
      type: recipe.type
    });

    // Update recipe ID with saved ID
    recipe.id = savedRecipe._id.toString();

    res.json(recipe);
  } catch (err) {
    console.error("Generate recipe error:", err);
    res.status(500).json({ error: "Failed to generate recipe" });
  }
});

// POST /recipes/veganize
router.post("/veganize", async (req, res) => {
  try {
    const { userId, inputText } = req.body;

    if (!userId || !inputText) {
      return res.status(400).json({ error: "userId and inputText are required" });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Extract ingredients
    console.log("ðŸ” Calling LLM (extractIngredients) for recipe veganization...");
    console.log("   User ID:", userId);
    console.log("   Recipe text length:", inputText.length, "characters");
    const ingredients = await extractIngredients(inputText);
    console.log("âœ… LLM extracted", ingredients.length, "ingredients");
    console.log("   Ingredients:", ingredients.slice(0, 5).join(", "), ingredients.length > 5 ? "..." : "");

    // Get substitutions
    const substitutions = JSON.parse(readFileSync(join(__dirname, "../config/substitutions.json"), "utf-8"));

    const dietLevel = user.dietLevel?.toLowerCase() || "vegan";
    const adaptedIngredients = [];
    const substitutionMap = {};

    for (const ing of ingredients) {
      const key = ing.toUpperCase();
      const subs = substitutions[key]?.[dietLevel] || [];
      
      if (subs.length > 0) {
        adaptedIngredients.push({
          original: ing,
          substitute: subs[0] // Use first substitution
        });
        substitutionMap[ing] = subs[0];
      }
    }

    // Rewrite recipe
    console.log("ðŸ” Calling LLM (rewriteRecipeSteps) to veganize recipe...");
    console.log("   Substitutions count:", adaptedIngredients.length);
    const newRecipeText = await rewriteRecipeSteps(adaptedIngredients, inputText);
    console.log("âœ… LLM rewrote recipe successfully");
    console.log("   Veganized recipe length:", newRecipeText.length, "characters");

    // Convert recipe text to steps array
    const steps = newRecipeText
      .split(/\n+/)
      .map(s => s.trim())
      .filter(s => s.length > 0)
      .filter(s => !s.match(/^(recipe|ingredients|instructions|method|steps?):?$/i));
    
    const finalSteps = steps.length > 0 ? steps : [newRecipeText];

    // Map ingredients to RecipeIngredient format
    const recipeIngredients = adaptedIngredients.map(item => ({
      name: item.substitute,
      amount: null,
      unit: null
    }));

    // Create full Recipe object matching Swift model
    const recipe = {
      id: new mongoose.Types.ObjectId().toString(),
      userId: userId,
      title: "Veganized Recipe",
      tags: [],
      duration: "30 min",
      ingredients: recipeIngredients,
      steps: finalSteps,
      previewImageUrl: "",
      originalPrompt: inputText,
      type: "veganized",
      substitutionMap: substitutionMap
    };

    // Save recipe
    const savedRecipe = await Recipe.create({
      userID: userId,
      recipe: finalSteps,
      title: recipe.title,
      tags: recipe.tags,
      duration: recipe.duration,
      ingredients: recipe.ingredients,
      type: recipe.type,
      substitutionMap: recipe.substitutionMap
    });

    recipe.id = savedRecipe._id.toString();

    res.json(recipe);
  } catch (err) {
    console.error("Veganize recipe error:", err);
    res.status(500).json({ error: "Failed to veganize recipe" });
  }
});

// GET /recipes/saved?userId=...
router.get("/saved", async (req, res) => {
  try {
    const userId = req.query.userId;

    if (!userId) {
      return res.status(400).json({ error: "userId is required" });
    }

    const recipes = await Recipe.find({ userID: userId });

    // Map to iOS Recipe format - ensure all fields match Swift model
    const savedRecipes = recipes.map(r => ({
      id: r._id.toString(),
      userId: r.userID?.toString() || null,
      title: r.title || "Saved Recipe",
      tags: r.tags || [],
      duration: r.duration || "",
      ingredients: (r.ingredients || []).map(i => ({
        name: i.name || "",
        amount: i.amount || null,
        unit: i.unit || null
      })),
      steps: r.recipe || [], // recipe field contains steps array
      previewImageUrl: r.previewImageUrl || "",
      originalPrompt: r.originalPrompt || null,
      type: r.type || "simplified",
      substitutionMap: r.substitutionMap || null
    }));

    res.json(savedRecipes);
  } catch (err) {
    console.error("Get saved recipes error:", err);
    res.status(500).json({ error: "Failed to get saved recipes" });
  }
});

// POST /recipes/save
router.post("/save", async (req, res) => {
  try {
    const { userId, recipe } = req.body;

    if (!userId || !recipe) {
      return res.status(400).json({ error: "userId and recipe are required" });
    }

    // Save recipe - match Swift Recipe model structure
    const savedRecipe = await Recipe.create({
      userID: userId,
      recipe: recipe.steps || [], // Store steps array
      title: recipe.title || "Saved Recipe",
      tags: recipe.tags || [],
      duration: recipe.duration || "",
      ingredients: recipe.ingredients || [],
      previewImageUrl: recipe.previewImageUrl || "",
      originalPrompt: recipe.originalPrompt || null,
      type: recipe.type || "simplified",
      substitutionMap: recipe.substitutionMap || null
    });

    // Return in iOS Recipe format - exact match to Swift model
    const saved = {
      id: savedRecipe._id.toString(),
      userId: savedRecipe.userID?.toString() || null,
      title: savedRecipe.title || recipe.title || "Saved Recipe",
      tags: savedRecipe.tags || recipe.tags || [],
      duration: savedRecipe.duration || recipe.duration || "",
      ingredients: (savedRecipe.ingredients || recipe.ingredients || []).map(i => ({
        name: i.name || "",
        amount: i.amount || null,
        unit: i.unit || null
      })),
      steps: savedRecipe.recipe || recipe.steps || [],
      previewImageUrl: savedRecipe.previewImageUrl || recipe.previewImageUrl || "",
      originalPrompt: savedRecipe.originalPrompt || recipe.originalPrompt || null,
      type: savedRecipe.type || recipe.type || "simplified",
      substitutionMap: savedRecipe.substitutionMap || recipe.substitutionMap || null
    };

    res.json(saved);
  } catch (err) {
    console.error("Save recipe error:", err);
    res.status(500).json({ error: "Failed to save recipe" });
  }
});

export default router;
